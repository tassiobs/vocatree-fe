{"ast":null,"code":"// Mock API for testing frontend without backend\n\n// Mock data\nconst mockCards = [{\n  id: 1,\n  name: \"Business Vocabulary\",\n  parent_id: null,\n  children: [{\n    id: 2,\n    name: \"Meeting Terms\",\n    parent_id: 1,\n    children: [],\n    example_phrases: [\"Let's schedule a meeting\", \"The meeting was productive\"],\n    meanings: [\"A gathering to discuss business matters\"],\n    grammar_roles: [\"noun\"],\n    collocations: [\"schedule a meeting\", \"attend a meeting\"],\n    synonyms: [\"conference\", \"gathering\"],\n    antonyms: [],\n    use_count: 5,\n    notes: \"Common in professional settings\",\n    created_at: \"2024-01-01T00:00:00Z\",\n    user_created: 1\n  }],\n  example_phrases: [],\n  meanings: [],\n  grammar_roles: [],\n  collocations: [],\n  synonyms: [],\n  antonyms: [],\n  use_count: 0,\n  notes: null,\n  created_at: \"2024-01-01T00:00:00Z\",\n  user_created: 1\n}, {\n  id: 3,\n  name: \"Academic Words\",\n  parent_id: null,\n  children: [{\n    id: 4,\n    name: \"Research Terms\",\n    parent_id: 3,\n    children: [],\n    example_phrases: [\"Conduct research\", \"Analyze data\"],\n    meanings: [\"Systematic investigation\"],\n    grammar_roles: [\"noun\", \"verb\"],\n    collocations: [\"conduct research\", \"research findings\"],\n    synonyms: [\"investigation\", \"study\"],\n    antonyms: [],\n    use_count: 3,\n    notes: \"Essential for academic writing\",\n    created_at: \"2024-01-01T00:00:00Z\",\n    user_created: 1\n  }],\n  example_phrases: [],\n  meanings: [],\n  grammar_roles: [],\n  collocations: [],\n  synonyms: [],\n  antonyms: [],\n  use_count: 0,\n  notes: null,\n  created_at: \"2024-01-01T00:00:00Z\",\n  user_created: 1\n}];\nlet nextId = 5;\n\n// Mock API functions\nexport const mockApi = {\n  async signIn(credentials) {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    // Mock authentication - accept any email/password for testing\n    return {\n      access_token: \"mock-token-\" + Date.now(),\n      token_type: \"bearer\",\n      expires_in: 3600\n    };\n  },\n  async getCardsHierarchy() {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return mockCards;\n  },\n  async createCard(card) {\n    var _card$parent_id, _card$notes;\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const newCard = {\n      id: nextId++,\n      name: card.name,\n      parent_id: (_card$parent_id = card.parent_id) !== null && _card$parent_id !== void 0 ? _card$parent_id : null,\n      children: [],\n      example_phrases: card.example_phrases || [],\n      meanings: card.meanings || [],\n      grammar_roles: card.grammar_roles || [],\n      collocations: card.collocations || [],\n      synonyms: card.synonyms || [],\n      antonyms: card.antonyms || [],\n      use_count: card.use_count || 0,\n      notes: (_card$notes = card.notes) !== null && _card$notes !== void 0 ? _card$notes : null,\n      created_at: new Date().toISOString(),\n      user_created: 1\n    };\n\n    // Add to mock data\n    if (card.parent_id === null || card.parent_id === undefined) {\n      mockCards.push(newCard);\n    } else {\n      const parent = this.findCardById(card.parent_id);\n      if (parent) {\n        parent.children = parent.children || [];\n        parent.children.push(newCard);\n      }\n    }\n    return newCard;\n  },\n  async updateCard(id, updates) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const card = this.findCardById(id);\n    if (!card) {\n      throw new Error(\"Card not found\");\n    }\n\n    // Update card properties\n    Object.assign(card, updates);\n    return card;\n  },\n  async deleteCard(id) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const removeFromArray = cards => {\n      for (let i = 0; i < cards.length; i++) {\n        if (cards[i].id === id) {\n          cards.splice(i, 1);\n          return true;\n        }\n        if (cards[i].children && cards[i].children.length > 0) {\n          if (removeFromArray(cards[i].children)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    if (!removeFromArray(mockCards)) {\n      throw new Error(\"Card not found\");\n    }\n  },\n  async moveCard(id, newParentId) {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const card = this.findCardById(id);\n    if (!card) {\n      throw new Error(\"Card not found\");\n    }\n\n    // Remove from current parent\n    const removeFromParent = cards => {\n      for (let i = 0; i < cards.length; i++) {\n        if (cards[i].id === id) {\n          cards.splice(i, 1);\n          return true;\n        }\n        if (cards[i].children && cards[i].children.length > 0) {\n          if (removeFromParent(cards[i].children)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    removeFromParent(mockCards);\n\n    // Add to new parent\n    if (newParentId === null) {\n      mockCards.push(card);\n    } else {\n      const newParent = this.findCardById(newParentId);\n      if (newParent) {\n        newParent.children = newParent.children || [];\n        newParent.children.push(card);\n      }\n    }\n    card.parent_id = newParentId;\n  },\n  findCardById(id) {\n    const findInArray = cards => {\n      for (const card of cards) {\n        if (card.id === id) return card;\n        if (card.children) {\n          const found = findInArray(card.children);\n          if (found) return found;\n        }\n      }\n      return null;\n    };\n    return findInArray(mockCards);\n  }\n};","map":{"version":3,"names":["mockCards","id","name","parent_id","children","example_phrases","meanings","grammar_roles","collocations","synonyms","antonyms","use_count","notes","created_at","user_created","nextId","mockApi","signIn","credentials","Promise","resolve","setTimeout","access_token","Date","now","token_type","expires_in","getCardsHierarchy","createCard","card","_card$parent_id","_card$notes","newCard","toISOString","undefined","push","parent","findCardById","updateCard","updates","Error","Object","assign","deleteCard","removeFromArray","cards","i","length","splice","moveCard","newParentId","removeFromParent","newParent","findInArray","found"],"sources":["/Users/tassiobs/Documents/vocatree-front/src/services/mockApi.ts"],"sourcesContent":["// Mock API for testing frontend without backend\nimport { AuthToken, Card, CardCreate, CardUpdate } from '../types/api';\n\n// Mock data\nconst mockCards: Card[] = [\n  {\n    id: 1,\n    name: \"Business Vocabulary\",\n    parent_id: null,\n    children: [\n      {\n        id: 2,\n        name: \"Meeting Terms\",\n        parent_id: 1,\n        children: [],\n        example_phrases: [\"Let's schedule a meeting\", \"The meeting was productive\"],\n        meanings: [\"A gathering to discuss business matters\"],\n        grammar_roles: [\"noun\"],\n        collocations: [\"schedule a meeting\", \"attend a meeting\"],\n        synonyms: [\"conference\", \"gathering\"],\n        antonyms: [],\n        use_count: 5,\n        notes: \"Common in professional settings\",\n        created_at: \"2024-01-01T00:00:00Z\",\n        user_created: 1\n      }\n    ],\n    example_phrases: [],\n    meanings: [],\n    grammar_roles: [],\n    collocations: [],\n    synonyms: [],\n    antonyms: [],\n    use_count: 0,\n    notes: null,\n    created_at: \"2024-01-01T00:00:00Z\",\n    user_created: 1\n  },\n  {\n    id: 3,\n    name: \"Academic Words\",\n    parent_id: null,\n    children: [\n      {\n        id: 4,\n        name: \"Research Terms\",\n        parent_id: 3,\n        children: [],\n        example_phrases: [\"Conduct research\", \"Analyze data\"],\n        meanings: [\"Systematic investigation\"],\n        grammar_roles: [\"noun\", \"verb\"],\n        collocations: [\"conduct research\", \"research findings\"],\n        synonyms: [\"investigation\", \"study\"],\n        antonyms: [],\n        use_count: 3,\n        notes: \"Essential for academic writing\",\n        created_at: \"2024-01-01T00:00:00Z\",\n        user_created: 1\n      }\n    ],\n    example_phrases: [],\n    meanings: [],\n    grammar_roles: [],\n    collocations: [],\n    synonyms: [],\n    antonyms: [],\n    use_count: 0,\n    notes: null,\n    created_at: \"2024-01-01T00:00:00Z\",\n    user_created: 1\n  }\n];\n\nlet nextId = 5;\n\n// Mock API functions\nexport const mockApi = {\n  async signIn(credentials: { email: string; password: string }): Promise<AuthToken> {\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Mock authentication - accept any email/password for testing\n    return {\n      access_token: \"mock-token-\" + Date.now(),\n      token_type: \"bearer\",\n      expires_in: 3600\n    };\n  },\n\n  async getCardsHierarchy(): Promise<Card[]> {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    return mockCards;\n  },\n\n  async createCard(card: CardCreate): Promise<Card> {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const newCard: Card = {\n      id: nextId++,\n      name: card.name,\n      parent_id: card.parent_id ?? null,\n      children: [],\n      example_phrases: card.example_phrases || [],\n      meanings: card.meanings || [],\n      grammar_roles: card.grammar_roles || [],\n      collocations: card.collocations || [],\n      synonyms: card.synonyms || [],\n      antonyms: card.antonyms || [],\n      use_count: card.use_count || 0,\n      notes: card.notes ?? null,\n      created_at: new Date().toISOString(),\n      user_created: 1\n    };\n\n    // Add to mock data\n    if (card.parent_id === null || card.parent_id === undefined) {\n      mockCards.push(newCard);\n    } else {\n      const parent = this.findCardById(card.parent_id);\n      if (parent) {\n        parent.children = parent.children || [];\n        parent.children.push(newCard);\n      }\n    }\n\n    return newCard;\n  },\n\n  async updateCard(id: number, updates: CardUpdate): Promise<Card> {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const card = this.findCardById(id);\n    if (!card) {\n      throw new Error(\"Card not found\");\n    }\n\n    // Update card properties\n    Object.assign(card, updates);\n    return card;\n  },\n\n  async deleteCard(id: number): Promise<void> {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const removeFromArray = (cards: Card[]): boolean => {\n      for (let i = 0; i < cards.length; i++) {\n        if (cards[i].id === id) {\n          cards.splice(i, 1);\n          return true;\n        }\n        if (cards[i].children && cards[i].children.length > 0) {\n          if (removeFromArray(cards[i].children!)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    if (!removeFromArray(mockCards)) {\n      throw new Error(\"Card not found\");\n    }\n  },\n\n  async moveCard(id: number, newParentId: number | null): Promise<void> {\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    const card = this.findCardById(id);\n    if (!card) {\n      throw new Error(\"Card not found\");\n    }\n\n    // Remove from current parent\n    const removeFromParent = (cards: Card[]): boolean => {\n      for (let i = 0; i < cards.length; i++) {\n        if (cards[i].id === id) {\n          cards.splice(i, 1);\n          return true;\n        }\n        if (cards[i].children && cards[i].children.length > 0) {\n          if (removeFromParent(cards[i].children!)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    removeFromParent(mockCards);\n\n    // Add to new parent\n    if (newParentId === null) {\n      mockCards.push(card);\n    } else {\n      const newParent = this.findCardById(newParentId);\n      if (newParent) {\n        newParent.children = newParent.children || [];\n        newParent.children.push(card);\n      }\n    }\n\n    card.parent_id = newParentId;\n  },\n\n  findCardById(id: number): Card | null {\n    const findInArray = (cards: Card[]): Card | null => {\n      for (const card of cards) {\n        if (card.id === id) return card;\n        if (card.children) {\n          const found = findInArray(card.children);\n          if (found) return found;\n        }\n      }\n      return null;\n    };\n    return findInArray(mockCards);\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}