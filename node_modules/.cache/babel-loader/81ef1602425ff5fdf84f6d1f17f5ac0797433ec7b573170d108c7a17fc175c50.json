{"ast":null,"code":"// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = card => {\n  return {\n    id: card.id,\n    name: card.name,\n    type: 'card',\n    parent_id: card.parent_id,\n    children: card.children && card.children.length > 0 ? card.children.map(childCard => cardToTreeItem(childCard)) : [],\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created\n  };\n};\n\n// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree = cards => {\n  // The /cards/hierarchy endpoint returns cards with children already populated\n  // So we just need to recursively convert them to TreeItems\n  const treeItems = cards.map(card => cardToTreeItem(card));\n\n  // Sort children by name\n  const sortChildren = items => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n  sortChildren(treeItems);\n  return treeItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree, id) => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree, id, updates) => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return {\n        ...item,\n        ...updates\n      };\n    }\n    if (item.children.length > 0) {\n      return {\n        ...item,\n        children: updateTreeItem(item.children, id, updates)\n      };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree, id) => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (tree, itemId, newParentId) => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n\n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    var _findTreeItem;\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(((_findTreeItem = findTreeItem(updatedTree, newParentId)) === null || _findTreeItem === void 0 ? void 0 : _findTreeItem.children) || []), itemToMove]\n    });\n  }\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree, itemId) => {\n  const findParentIds = (items, targetId, currentPath) => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = tree => {\n  const result = [];\n  const traverse = items => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  traverse(tree);\n  return result;\n};","map":{"version":3,"names":["cardToTreeItem","card","id","name","type","parent_id","children","length","map","childCard","example_phrases","meanings","grammar_roles","collocations","synonyms","antonyms","use_count","notes","created_at","user_created","buildTree","cards","treeItems","sortChildren","items","sort","a","b","localeCompare","forEach","item","findTreeItem","tree","found","updateTreeItem","updates","removeTreeItem","filter","moveTreeItem","itemId","newParentId","itemToMove","updatedTree","push","_findTreeItem","getParentIds","findParentIds","targetId","currentPath","newPath","result","flattenTree","traverse"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/utils/treeUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { Card } from '../types/api';\n\n// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = (card: Card): TreeItem => {\n  return {\n    id: card.id,\n    name: card.name,\n    type: 'card',\n    parent_id: card.parent_id,\n    children: card.children && card.children.length > 0 \n      ? card.children.map(childCard => cardToTreeItem(childCard))\n      : [],\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created,\n  };\n};\n\n// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree = (cards: Card[]): TreeItem[] => {\n  // The /cards/hierarchy endpoint returns cards with children already populated\n  // So we just need to recursively convert them to TreeItems\n  const treeItems = cards.map(card => cardToTreeItem(card));\n  \n  // Sort children by name\n  const sortChildren = (items: TreeItem[]) => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    \n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n\n  sortChildren(treeItems);\n  return treeItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree: TreeItem[], id: number): TreeItem | null => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree: TreeItem[], id: number, updates: Partial<TreeItem>): TreeItem[] => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return { ...item, ...updates };\n    }\n    if (item.children.length > 0) {\n      return { ...item, children: updateTreeItem(item.children, id, updates) };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree: TreeItem[], id: number): TreeItem[] => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (\n  tree: TreeItem[], \n  itemId: number, \n  newParentId: number | null\n): TreeItem[] => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n  \n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(findTreeItem(updatedTree, newParentId)?.children || []), itemToMove]\n    });\n  }\n\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree: TreeItem[], itemId: number): number[] => {\n  const findParentIds = (items: TreeItem[], targetId: number, currentPath: number[]): number[] | null => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      \n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      \n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = (tree: TreeItem[]): TreeItem[] => {\n  const result: TreeItem[] = [];\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return result;\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}