{"ast":null,"code":"// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = card => {\n  const children = card.children && card.children.length > 0 ? card.children.map(childCard => cardToTreeItem(childCard)) : [];\n  return {\n    id: card.id,\n    name: card.name,\n    type: card.is_folder ? 'folder' : 'card',\n    parent_id: card.parent_id,\n    is_folder: card.is_folder,\n    children: children,\n    isExpanded: false,\n    // Start collapsed\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created\n  };\n};\n\n// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree = (cards, expandedIds) => {\n  // The /cards/hierarchy endpoint returns cards with children already populated\n  // So we just need to recursively convert them to TreeItems\n  const cardToTreeItemWithExpanded = card => {\n    const children = card.children && card.children.length > 0 ? card.children.map(childCard => cardToTreeItemWithExpanded(childCard)) : [];\n    return {\n      id: card.id,\n      name: card.name,\n      type: card.is_folder ? 'folder' : 'card',\n      parent_id: card.parent_id,\n      is_folder: card.is_folder,\n      children: children,\n      isExpanded: expandedIds ? expandedIds.has(card.id) : false,\n      // Preserve expanded state\n      example_phrases: card.example_phrases,\n      meanings: card.meanings,\n      grammar_roles: card.grammar_roles,\n      collocations: card.collocations,\n      synonyms: card.synonyms,\n      antonyms: card.antonyms,\n      use_count: card.use_count,\n      notes: card.notes,\n      created_at: card.created_at,\n      user_created: card.user_created\n    };\n  };\n  const treeItems = cards.map(card => cardToTreeItemWithExpanded(card));\n\n  // Sort children by name\n  const sortChildren = items => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n  sortChildren(treeItems);\n  return treeItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree, id) => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree, id, updates) => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return {\n        ...item,\n        ...updates\n      };\n    }\n    if (item.children.length > 0) {\n      return {\n        ...item,\n        children: updateTreeItem(item.children, id, updates)\n      };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree, id) => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (tree, itemId, newParentId) => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n\n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    var _findTreeItem;\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(((_findTreeItem = findTreeItem(updatedTree, newParentId)) === null || _findTreeItem === void 0 ? void 0 : _findTreeItem.children) || []), itemToMove]\n    });\n  }\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree, itemId) => {\n  const findParentIds = (items, targetId, currentPath) => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = tree => {\n  const result = [];\n  const traverse = items => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  traverse(tree);\n  return result;\n};\n\n// Get all expanded item IDs from a tree\nexport const getExpandedIds = tree => {\n  const expandedIds = new Set();\n  const traverse = items => {\n    items.forEach(item => {\n      if (item.isExpanded) {\n        expandedIds.add(item.id);\n      }\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  traverse(tree);\n  return expandedIds;\n};\n\n// Move item across categories or within a category\n// This function handles both moving within a category and moving between categories\nexport const moveItemAcrossCategories = (categories, itemId, newParentId, newCategoryId) => {\n  // Find the item across all categories\n  let itemToMove = null;\n  let sourceCategoryIndex = -1;\n  for (let i = 0; i < categories.length; i++) {\n    const found = findTreeItem(categories[i].children, itemId);\n    if (found) {\n      itemToMove = found;\n      sourceCategoryIndex = i;\n      break;\n    }\n  }\n  if (!itemToMove || sourceCategoryIndex === -1) {\n    return categories;\n  }\n\n  // Create a copy of the item with updated parent_id and category_id\n  const updatedItem = {\n    ...itemToMove,\n    parent_id: newParentId,\n    category_id: newCategoryId !== null ? newCategoryId : itemToMove.category_id\n  };\n\n  // Remove from source category\n  const updatedCategories = categories.map((category, index) => {\n    if (index === sourceCategoryIndex) {\n      return {\n        ...category,\n        children: removeTreeItem(category.children, itemId)\n      };\n    }\n    return category;\n  });\n\n  // Add to target category\n  const targetCategoryIndex = newCategoryId !== null ? updatedCategories.findIndex(cat => cat.id === newCategoryId) : sourceCategoryIndex; // If no category_id specified, stay in same category\n\n  if (targetCategoryIndex === -1) {\n    // Target category not found, return original\n    return categories;\n  }\n\n  // Add item to target location\n  if (newParentId === null) {\n    // Moving to root of target category\n    updatedCategories[targetCategoryIndex] = {\n      ...updatedCategories[targetCategoryIndex],\n      children: [...updatedCategories[targetCategoryIndex].children, updatedItem]\n    };\n  } else {\n    // Moving to a specific folder in target category\n    const targetCategory = updatedCategories[targetCategoryIndex];\n    const parentItem = findTreeItem(targetCategory.children, newParentId);\n    if (parentItem) {\n      // Update the parent's children\n      updatedCategories[targetCategoryIndex] = {\n        ...targetCategory,\n        children: updateTreeItem(targetCategory.children, newParentId, {\n          children: [...(parentItem.children || []), updatedItem]\n        })\n      };\n    } else {\n      // Parent not found, add to root as fallback\n      updatedCategories[targetCategoryIndex] = {\n        ...targetCategory,\n        children: [...targetCategory.children, updatedItem]\n      };\n    }\n  }\n  return updatedCategories;\n};","map":{"version":3,"names":["cardToTreeItem","card","children","length","map","childCard","id","name","type","is_folder","parent_id","isExpanded","example_phrases","meanings","grammar_roles","collocations","synonyms","antonyms","use_count","notes","created_at","user_created","buildTree","cards","expandedIds","cardToTreeItemWithExpanded","has","treeItems","sortChildren","items","sort","a","b","localeCompare","forEach","item","findTreeItem","tree","found","updateTreeItem","updates","removeTreeItem","filter","moveTreeItem","itemId","newParentId","itemToMove","updatedTree","push","_findTreeItem","getParentIds","findParentIds","targetId","currentPath","newPath","result","flattenTree","traverse","getExpandedIds","Set","add","moveItemAcrossCategories","categories","newCategoryId","sourceCategoryIndex","i","updatedItem","category_id","updatedCategories","category","index","targetCategoryIndex","findIndex","cat","targetCategory","parentItem"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/utils/treeUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { Card } from '../types/api';\n\n// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = (card: Card): TreeItem => {\n  const children = card.children && card.children.length > 0 \n    ? card.children.map(childCard => cardToTreeItem(childCard))\n    : [];\n  \n  return {\n    id: card.id,\n    name: card.name,\n    type: card.is_folder ? 'folder' : 'card',\n    parent_id: card.parent_id,\n    is_folder: card.is_folder,\n    children: children,\n    isExpanded: false, // Start collapsed\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created,\n  };\n};\n\n// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree = (cards: Card[], expandedIds?: Set<number>): TreeItem[] => {\n  // The /cards/hierarchy endpoint returns cards with children already populated\n  // So we just need to recursively convert them to TreeItems\n  const cardToTreeItemWithExpanded = (card: Card): TreeItem => {\n    const children = card.children && card.children.length > 0 \n      ? card.children.map(childCard => cardToTreeItemWithExpanded(childCard))\n      : [];\n    \n    return {\n      id: card.id,\n      name: card.name,\n      type: card.is_folder ? 'folder' : 'card',\n      parent_id: card.parent_id,\n      is_folder: card.is_folder,\n      children: children,\n      isExpanded: expandedIds ? expandedIds.has(card.id) : false, // Preserve expanded state\n      example_phrases: card.example_phrases,\n      meanings: card.meanings,\n      grammar_roles: card.grammar_roles,\n      collocations: card.collocations,\n      synonyms: card.synonyms,\n      antonyms: card.antonyms,\n      use_count: card.use_count,\n      notes: card.notes,\n      created_at: card.created_at,\n      user_created: card.user_created,\n    };\n  };\n\n  const treeItems = cards.map(card => cardToTreeItemWithExpanded(card));\n  \n  // Sort children by name\n  const sortChildren = (items: TreeItem[]) => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    \n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n\n  sortChildren(treeItems);\n  return treeItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree: TreeItem[], id: number): TreeItem | null => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree: TreeItem[], id: number, updates: Partial<TreeItem>): TreeItem[] => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return { ...item, ...updates };\n    }\n    if (item.children.length > 0) {\n      return { ...item, children: updateTreeItem(item.children, id, updates) };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree: TreeItem[], id: number): TreeItem[] => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (\n  tree: TreeItem[], \n  itemId: number, \n  newParentId: number | null\n): TreeItem[] => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n  \n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(findTreeItem(updatedTree, newParentId)?.children || []), itemToMove]\n    });\n  }\n\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree: TreeItem[], itemId: number): number[] => {\n  const findParentIds = (items: TreeItem[], targetId: number, currentPath: number[]): number[] | null => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      \n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      \n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = (tree: TreeItem[]): TreeItem[] => {\n  const result: TreeItem[] = [];\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return result;\n};\n\n// Get all expanded item IDs from a tree\nexport const getExpandedIds = (tree: TreeItem[]): Set<number> => {\n  const expandedIds = new Set<number>();\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      if (item.isExpanded) {\n        expandedIds.add(item.id);\n      }\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return expandedIds;\n};\n\n// Move item across categories or within a category\n// This function handles both moving within a category and moving between categories\nexport const moveItemAcrossCategories = (\n  categories: Array<{ id: number; children: TreeItem[] }>,\n  itemId: number,\n  newParentId: number | null,\n  newCategoryId: number | null\n): Array<{ id: number; children: TreeItem[] }> => {\n  // Find the item across all categories\n  let itemToMove: TreeItem | null = null;\n  let sourceCategoryIndex = -1;\n  \n  for (let i = 0; i < categories.length; i++) {\n    const found = findTreeItem(categories[i].children, itemId);\n    if (found) {\n      itemToMove = found;\n      sourceCategoryIndex = i;\n      break;\n    }\n  }\n  \n  if (!itemToMove || sourceCategoryIndex === -1) {\n    return categories;\n  }\n  \n  // Create a copy of the item with updated parent_id and category_id\n  const updatedItem: TreeItem = {\n    ...itemToMove,\n    parent_id: newParentId,\n    category_id: newCategoryId !== null ? newCategoryId : itemToMove.category_id,\n  };\n  \n  // Remove from source category\n  const updatedCategories = categories.map((category, index) => {\n    if (index === sourceCategoryIndex) {\n      return {\n        ...category,\n        children: removeTreeItem(category.children, itemId),\n      };\n    }\n    return category;\n  });\n  \n  // Add to target category\n  const targetCategoryIndex = newCategoryId !== null \n    ? updatedCategories.findIndex(cat => cat.id === newCategoryId)\n    : sourceCategoryIndex; // If no category_id specified, stay in same category\n  \n  if (targetCategoryIndex === -1) {\n    // Target category not found, return original\n    return categories;\n  }\n  \n  // Add item to target location\n  if (newParentId === null) {\n    // Moving to root of target category\n    updatedCategories[targetCategoryIndex] = {\n      ...updatedCategories[targetCategoryIndex],\n      children: [...updatedCategories[targetCategoryIndex].children, updatedItem],\n    };\n  } else {\n    // Moving to a specific folder in target category\n    const targetCategory = updatedCategories[targetCategoryIndex];\n    const parentItem = findTreeItem(targetCategory.children, newParentId);\n    if (parentItem) {\n      // Update the parent's children\n      updatedCategories[targetCategoryIndex] = {\n        ...targetCategory,\n        children: updateTreeItem(targetCategory.children, newParentId, {\n          children: [...(parentItem.children || []), updatedItem],\n        }),\n      };\n    } else {\n      // Parent not found, add to root as fallback\n      updatedCategories[targetCategoryIndex] = {\n        ...targetCategory,\n        children: [...targetCategory.children, updatedItem],\n      };\n    }\n  }\n  \n  return updatedCategories;\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}