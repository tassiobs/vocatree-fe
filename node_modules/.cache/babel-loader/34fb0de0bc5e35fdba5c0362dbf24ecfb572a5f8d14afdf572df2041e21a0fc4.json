{"ast":null,"code":"// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = card => {\n  return {\n    id: card.id,\n    name: card.name,\n    type: 'card',\n    parent_id: card.parent_id,\n    children: card.children && card.children.length > 0 ? card.children.map(childCard => cardToTreeItem(childCard)) : [],\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created\n  };\n};\n\n// Build tree structure from flat array of cards\nexport const buildTree = cards => {\n  const cardMap = new Map();\n  const rootItems = [];\n\n  // First pass: create all items\n  cards.forEach(card => {\n    const treeItem = cardToTreeItem(card);\n    cardMap.set(card.id, treeItem);\n  });\n\n  // Second pass: build parent-child relationships\n  cards.forEach(card => {\n    const treeItem = cardMap.get(card.id);\n    if (card.parent_id === null) {\n      rootItems.push(treeItem);\n    } else {\n      const parent = cardMap.get(card.parent_id);\n      if (parent) {\n        parent.children.push(treeItem);\n      }\n    }\n  });\n\n  // Sort children by name\n  const sortChildren = items => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n  sortChildren(rootItems);\n  return rootItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree, id) => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree, id, updates) => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return {\n        ...item,\n        ...updates\n      };\n    }\n    if (item.children.length > 0) {\n      return {\n        ...item,\n        children: updateTreeItem(item.children, id, updates)\n      };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree, id) => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (tree, itemId, newParentId) => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n\n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    var _findTreeItem;\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(((_findTreeItem = findTreeItem(updatedTree, newParentId)) === null || _findTreeItem === void 0 ? void 0 : _findTreeItem.children) || []), itemToMove]\n    });\n  }\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree, itemId) => {\n  const findParentIds = (items, targetId, currentPath) => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = tree => {\n  const result = [];\n  const traverse = items => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  traverse(tree);\n  return result;\n};","map":{"version":3,"names":["cardToTreeItem","card","id","name","type","parent_id","children","length","map","childCard","example_phrases","meanings","grammar_roles","collocations","synonyms","antonyms","use_count","notes","created_at","user_created","buildTree","cards","cardMap","Map","rootItems","forEach","treeItem","set","get","push","parent","sortChildren","items","sort","a","b","localeCompare","item","findTreeItem","tree","found","updateTreeItem","updates","removeTreeItem","filter","moveTreeItem","itemId","newParentId","itemToMove","updatedTree","_findTreeItem","getParentIds","findParentIds","targetId","currentPath","newPath","result","flattenTree","traverse"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/utils/treeUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { Card } from '../types/api';\n\n// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = (card: Card): TreeItem => {\n  return {\n    id: card.id,\n    name: card.name,\n    type: 'card',\n    parent_id: card.parent_id,\n    children: card.children && card.children.length > 0 \n      ? card.children.map(childCard => cardToTreeItem(childCard))\n      : [],\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created,\n  };\n};\n\n// Build tree structure from flat array of cards\nexport const buildTree = (cards: Card[]): TreeItem[] => {\n  const cardMap = new Map<number, TreeItem>();\n  const rootItems: TreeItem[] = [];\n\n  // First pass: create all items\n  cards.forEach(card => {\n    const treeItem = cardToTreeItem(card);\n    cardMap.set(card.id, treeItem);\n  });\n\n  // Second pass: build parent-child relationships\n  cards.forEach(card => {\n    const treeItem = cardMap.get(card.id)!;\n    \n    if (card.parent_id === null) {\n      rootItems.push(treeItem);\n    } else {\n      const parent = cardMap.get(card.parent_id);\n      if (parent) {\n        parent.children.push(treeItem);\n      }\n    }\n  });\n\n  // Sort children by name\n  const sortChildren = (items: TreeItem[]) => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    \n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n\n  sortChildren(rootItems);\n  return rootItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree: TreeItem[], id: number): TreeItem | null => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree: TreeItem[], id: number, updates: Partial<TreeItem>): TreeItem[] => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return { ...item, ...updates };\n    }\n    if (item.children.length > 0) {\n      return { ...item, children: updateTreeItem(item.children, id, updates) };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree: TreeItem[], id: number): TreeItem[] => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (\n  tree: TreeItem[], \n  itemId: number, \n  newParentId: number | null\n): TreeItem[] => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n  \n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(findTreeItem(updatedTree, newParentId)?.children || []), itemToMove]\n    });\n  }\n\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree: TreeItem[], itemId: number): number[] => {\n  const findParentIds = (items: TreeItem[], targetId: number, currentPath: number[]): number[] | null => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      \n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      \n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = (tree: TreeItem[]): TreeItem[] => {\n  const result: TreeItem[] = [];\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return result;\n};\n\n"],"mappings":"AAGA;AACA,OAAO,MAAMA,cAAc,GAAIC,IAAU,IAAe;EACtD,OAAO;IACLC,EAAE,EAAED,IAAI,CAACC,EAAE;IACXC,IAAI,EAAEF,IAAI,CAACE,IAAI;IACfC,IAAI,EAAE,MAAM;IACZC,SAAS,EAAEJ,IAAI,CAACI,SAAS;IACzBC,QAAQ,EAAEL,IAAI,CAACK,QAAQ,IAAIL,IAAI,CAACK,QAAQ,CAACC,MAAM,GAAG,CAAC,GAC/CN,IAAI,CAACK,QAAQ,CAACE,GAAG,CAACC,SAAS,IAAIT,cAAc,CAACS,SAAS,CAAC,CAAC,GACzD,EAAE;IACNC,eAAe,EAAET,IAAI,CAACS,eAAe;IACrCC,QAAQ,EAAEV,IAAI,CAACU,QAAQ;IACvBC,aAAa,EAAEX,IAAI,CAACW,aAAa;IACjCC,YAAY,EAAEZ,IAAI,CAACY,YAAY;IAC/BC,QAAQ,EAAEb,IAAI,CAACa,QAAQ;IACvBC,QAAQ,EAAEd,IAAI,CAACc,QAAQ;IACvBC,SAAS,EAAEf,IAAI,CAACe,SAAS;IACzBC,KAAK,EAAEhB,IAAI,CAACgB,KAAK;IACjBC,UAAU,EAAEjB,IAAI,CAACiB,UAAU;IAC3BC,YAAY,EAAElB,IAAI,CAACkB;EACrB,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMC,SAAS,GAAIC,KAAa,IAAiB;EACtD,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAmB,CAAC;EAC3C,MAAMC,SAAqB,GAAG,EAAE;;EAEhC;EACAH,KAAK,CAACI,OAAO,CAACxB,IAAI,IAAI;IACpB,MAAMyB,QAAQ,GAAG1B,cAAc,CAACC,IAAI,CAAC;IACrCqB,OAAO,CAACK,GAAG,CAAC1B,IAAI,CAACC,EAAE,EAAEwB,QAAQ,CAAC;EAChC,CAAC,CAAC;;EAEF;EACAL,KAAK,CAACI,OAAO,CAACxB,IAAI,IAAI;IACpB,MAAMyB,QAAQ,GAAGJ,OAAO,CAACM,GAAG,CAAC3B,IAAI,CAACC,EAAE,CAAE;IAEtC,IAAID,IAAI,CAACI,SAAS,KAAK,IAAI,EAAE;MAC3BmB,SAAS,CAACK,IAAI,CAACH,QAAQ,CAAC;IAC1B,CAAC,MAAM;MACL,MAAMI,MAAM,GAAGR,OAAO,CAACM,GAAG,CAAC3B,IAAI,CAACI,SAAS,CAAC;MAC1C,IAAIyB,MAAM,EAAE;QACVA,MAAM,CAACxB,QAAQ,CAACuB,IAAI,CAACH,QAAQ,CAAC;MAChC;IACF;EACF,CAAC,CAAC;;EAEF;EACA,MAAMK,YAAY,GAAIC,KAAiB,IAAK;IAC1CA,KAAK,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MACnB;MACA,IAAID,CAAC,CAAC9B,IAAI,KAAK+B,CAAC,CAAC/B,IAAI,EAAE;QACrB,OAAO8B,CAAC,CAAC9B,IAAI,KAAK,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC;MACrC;MACA,OAAO8B,CAAC,CAAC/B,IAAI,CAACiC,aAAa,CAACD,CAAC,CAAChC,IAAI,CAAC;IACrC,CAAC,CAAC;IAEF6B,KAAK,CAACP,OAAO,CAACY,IAAI,IAAI;MACpB,IAAIA,IAAI,CAAC/B,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;QAC5BwB,YAAY,CAACM,IAAI,CAAC/B,QAAQ,CAAC;MAC7B;IACF,CAAC,CAAC;EACJ,CAAC;EAEDyB,YAAY,CAACP,SAAS,CAAC;EACvB,OAAOA,SAAS;AAClB,CAAC;;AAED;AACA,OAAO,MAAMc,YAAY,GAAGA,CAACC,IAAgB,EAAErC,EAAU,KAAsB;EAC7E,KAAK,MAAMmC,IAAI,IAAIE,IAAI,EAAE;IACvB,IAAIF,IAAI,CAACnC,EAAE,KAAKA,EAAE,EAAE;MAClB,OAAOmC,IAAI;IACb;IACA,MAAMG,KAAK,GAAGF,YAAY,CAACD,IAAI,CAAC/B,QAAQ,EAAEJ,EAAE,CAAC;IAC7C,IAAIsC,KAAK,EAAE;MACT,OAAOA,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMC,cAAc,GAAGA,CAACF,IAAgB,EAAErC,EAAU,EAAEwC,OAA0B,KAAiB;EACtG,OAAOH,IAAI,CAAC/B,GAAG,CAAC6B,IAAI,IAAI;IACtB,IAAIA,IAAI,CAACnC,EAAE,KAAKA,EAAE,EAAE;MAClB,OAAO;QAAE,GAAGmC,IAAI;QAAE,GAAGK;MAAQ,CAAC;IAChC;IACA,IAAIL,IAAI,CAAC/B,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;MAC5B,OAAO;QAAE,GAAG8B,IAAI;QAAE/B,QAAQ,EAAEmC,cAAc,CAACJ,IAAI,CAAC/B,QAAQ,EAAEJ,EAAE,EAAEwC,OAAO;MAAE,CAAC;IAC1E;IACA,OAAOL,IAAI;EACb,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,OAAO,MAAMM,cAAc,GAAGA,CAACJ,IAAgB,EAAErC,EAAU,KAAiB;EAC1E,OAAOqC,IAAI,CAACK,MAAM,CAACP,IAAI,IAAI;IACzB,IAAIA,IAAI,CAACnC,EAAE,KAAKA,EAAE,EAAE;MAClB,OAAO,KAAK;IACd;IACA,IAAImC,IAAI,CAAC/B,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;MAC5B8B,IAAI,CAAC/B,QAAQ,GAAGqC,cAAc,CAACN,IAAI,CAAC/B,QAAQ,EAAEJ,EAAE,CAAC;IACnD;IACA,OAAO,IAAI;EACb,CAAC,CAAC;AACJ,CAAC;;AAED;AACA,OAAO,MAAM2C,YAAY,GAAGA,CAC1BN,IAAgB,EAChBO,MAAc,EACdC,WAA0B,KACX;EACf;EACA,MAAMC,UAAU,GAAGV,YAAY,CAACC,IAAI,EAAEO,MAAM,CAAC;EAC7C,IAAI,CAACE,UAAU,EAAE;IACf,OAAOT,IAAI;EACb;;EAEA;EACA,IAAIU,WAAW,GAAGN,cAAc,CAACJ,IAAI,EAAEO,MAAM,CAAC;;EAE9C;EACAE,UAAU,CAAC3C,SAAS,GAAG0C,WAAW;;EAElC;EACA,IAAIA,WAAW,KAAK,IAAI,EAAE;IACxB;IACAE,WAAW,CAACpB,IAAI,CAACmB,UAAU,CAAC;EAC9B,CAAC,MAAM;IAAA,IAAAE,aAAA;IACL;IACAD,WAAW,GAAGR,cAAc,CAACQ,WAAW,EAAEF,WAAW,EAAE;MACrDzC,QAAQ,EAAE,CAAC,IAAI,EAAA4C,aAAA,GAAAZ,YAAY,CAACW,WAAW,EAAEF,WAAW,CAAC,cAAAG,aAAA,uBAAtCA,aAAA,CAAwC5C,QAAQ,KAAI,EAAE,CAAC,EAAE0C,UAAU;IACpF,CAAC,CAAC;EACJ;EAEA,OAAOC,WAAW;AACpB,CAAC;;AAED;AACA,OAAO,MAAME,YAAY,GAAGA,CAACZ,IAAgB,EAAEO,MAAc,KAAe;EAC1E,MAAMM,aAAa,GAAGA,CAACpB,KAAiB,EAAEqB,QAAgB,EAAEC,WAAqB,KAAsB;IACrG,KAAK,MAAMjB,IAAI,IAAIL,KAAK,EAAE;MACxB,MAAMuB,OAAO,GAAG,CAAC,GAAGD,WAAW,EAAEjB,IAAI,CAACnC,EAAE,CAAC;MAEzC,IAAImC,IAAI,CAACnC,EAAE,KAAKmD,QAAQ,EAAE;QACxB,OAAOC,WAAW,CAAC,CAAC;MACtB;MAEA,IAAIjB,IAAI,CAAC/B,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;QAC5B,MAAMiD,MAAM,GAAGJ,aAAa,CAACf,IAAI,CAAC/B,QAAQ,EAAE+C,QAAQ,EAAEE,OAAO,CAAC;QAC9D,IAAIC,MAAM,EAAE;UACV,OAAOA,MAAM;QACf;MACF;IACF;IACA,OAAO,IAAI;EACb,CAAC;EAED,OAAOJ,aAAa,CAACb,IAAI,EAAEO,MAAM,EAAE,EAAE,CAAC,IAAI,EAAE;AAC9C,CAAC;;AAED;AACA,OAAO,MAAMW,WAAW,GAAIlB,IAAgB,IAAiB;EAC3D,MAAMiB,MAAkB,GAAG,EAAE;EAE7B,MAAME,QAAQ,GAAI1B,KAAiB,IAAK;IACtCA,KAAK,CAACP,OAAO,CAACY,IAAI,IAAI;MACpBmB,MAAM,CAAC3B,IAAI,CAACQ,IAAI,CAAC;MACjB,IAAIA,IAAI,CAAC/B,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;QAC5BmD,QAAQ,CAACrB,IAAI,CAAC/B,QAAQ,CAAC;MACzB;IACF,CAAC,CAAC;EACJ,CAAC;EAEDoD,QAAQ,CAACnB,IAAI,CAAC;EACd,OAAOiB,MAAM;AACf,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}