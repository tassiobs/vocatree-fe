{"ast":null,"code":"import { apiClient } from '../services/api';\n\n/**\n * Check if a tree item has children (cards or folders)\n */\nexport const hasChildren = item => {\n  return item.children && item.children.length > 0;\n};\n\n/**\n * Get the count of children for a tree item\n */\nexport const getChildrenCount = item => {\n  return item.children ? item.children.length : 0;\n};\n\n/**\n * Recursively delete all children of a tree item\n */\nconst deleteChildrenRecursively = async children => {\n  for (const child of children) {\n    console.log(`Deleting child:`, child.id, child.name, child.is_folder ? 'folder' : 'card');\n    // If child has children, delete them first\n    if (hasChildren(child)) {\n      await deleteChildrenRecursively(child.children || []);\n    }\n    // Delete the child itself\n    try {\n      await apiClient.deleteCard(child.id);\n      console.log(`Successfully deleted child:`, child.id, child.name);\n    } catch (error) {\n      var _error$response;\n      if ((error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 404) {\n        console.warn(`Child ${child.id} (${child.name}) not found, continuing...`);\n      } else {\n        throw error; // Re-throw if it's not a 404 error\n      }\n    }\n  }\n};\n\n/**\n * Handle conditional delete for a tree item\n * Shows appropriate confirmation message based on whether the item has children\n */\nexport const handleConditionalDelete = async (item, onSuccess, onError) => {\n  const hasChildItems = hasChildren(item);\n  const childrenCount = getChildrenCount(item);\n  let confirmMessage;\n  if (hasChildItems) {\n    var _item$children, _item$children2;\n    const folderCount = ((_item$children = item.children) === null || _item$children === void 0 ? void 0 : _item$children.filter(child => child.is_folder).length) || 0;\n    const cardCount = ((_item$children2 = item.children) === null || _item$children2 === void 0 ? void 0 : _item$children2.filter(child => !child.is_folder).length) || 0;\n    let itemDescription = '';\n    if (folderCount > 0 && cardCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'} and ${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    } else if (folderCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'}`;\n    } else {\n      itemDescription = `${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    }\n    confirmMessage = `This ${item.is_folder ? 'folder' : 'category'} contains ${itemDescription}. Deleting it will also delete all items inside. Do you want to continue?`;\n  } else {\n    confirmMessage = `Are you sure you want to delete this ${item.is_folder ? 'folder' : 'card'}?`;\n  }\n  const confirmed = window.confirm(confirmMessage);\n  if (!confirmed) {\n    return;\n  }\n  try {\n    if (hasChildItems) {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'category'} with children recursively:`, item.id, item.name);\n      // Delete all children first (recursively)\n      await deleteChildrenRecursively(item.children || []);\n      // Then delete the parent\n      console.log(`Deleting parent ${item.is_folder ? 'folder' : 'category'}:`, item.id, item.name);\n      await apiClient.deleteCard(item.id);\n    } else {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'card'} without children using standard delete:`, item.id, item.name);\n      await apiClient.deleteCard(item.id);\n    }\n    onSuccess();\n  } catch (error) {\n    var _error$response2;\n    console.error('Error deleting item:', error);\n\n    // Handle specific error cases\n    if ((error === null || error === void 0 ? void 0 : (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) === 404) {\n      // Item not found - might have been deleted already\n      console.warn(`Item ${item.id} not found, might have been deleted already`);\n      // Still call onSuccess to update the UI since the item is effectively gone\n      onSuccess();\n      return;\n    }\n    if (onError) {\n      onError(error);\n    } else {\n      var _error$response3, _error$response3$data, _error$response4;\n      const errorMessage = (error === null || error === void 0 ? void 0 : (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : (_error$response3$data = _error$response3.data) === null || _error$response3$data === void 0 ? void 0 : _error$response3$data.detail) || (error === null || error === void 0 ? void 0 : error.message) || 'Unknown error occurred';\n      const statusCode = error === null || error === void 0 ? void 0 : (_error$response4 = error.response) === null || _error$response4 === void 0 ? void 0 : _error$response4.status;\n      if (statusCode === 404) {\n        alert(`The ${item.is_folder ? 'folder' : 'card'} was not found. It may have been deleted already.`);\n      } else {\n        alert(`Failed to delete ${item.is_folder ? 'folder' : 'card'}: ${errorMessage}`);\n      }\n    }\n  }\n};","map":{"version":3,"names":["apiClient","hasChildren","item","children","length","getChildrenCount","deleteChildrenRecursively","child","console","log","id","name","is_folder","deleteCard","error","_error$response","response","status","warn","handleConditionalDelete","onSuccess","onError","hasChildItems","childrenCount","confirmMessage","_item$children","_item$children2","folderCount","filter","cardCount","itemDescription","confirmed","window","confirm","_error$response2","_error$response3","_error$response3$data","_error$response4","errorMessage","data","detail","message","statusCode","alert"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/utils/deleteUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { apiClient } from '../services/api';\n\n/**\n * Check if a tree item has children (cards or folders)\n */\nexport const hasChildren = (item: TreeItem): boolean => {\n  return item.children && item.children.length > 0;\n};\n\n/**\n * Get the count of children for a tree item\n */\nexport const getChildrenCount = (item: TreeItem): number => {\n  return item.children ? item.children.length : 0;\n};\n\n/**\n * Recursively delete all children of a tree item\n */\nconst deleteChildrenRecursively = async (children: TreeItem[]): Promise<void> => {\n  for (const child of children) {\n    console.log(`Deleting child:`, child.id, child.name, child.is_folder ? 'folder' : 'card');\n    // If child has children, delete them first\n    if (hasChildren(child)) {\n      await deleteChildrenRecursively(child.children || []);\n    }\n    // Delete the child itself\n    try {\n      await apiClient.deleteCard(child.id);\n      console.log(`Successfully deleted child:`, child.id, child.name);\n    } catch (error: any) {\n      if (error?.response?.status === 404) {\n        console.warn(`Child ${child.id} (${child.name}) not found, continuing...`);\n      } else {\n        throw error; // Re-throw if it's not a 404 error\n      }\n    }\n  }\n};\n\n/**\n * Handle conditional delete for a tree item\n * Shows appropriate confirmation message based on whether the item has children\n */\nexport const handleConditionalDelete = async (\n  item: TreeItem,\n  onSuccess: () => void,\n  onError?: (error: any) => void\n): Promise<void> => {\n  const hasChildItems = hasChildren(item);\n  const childrenCount = getChildrenCount(item);\n  \n  let confirmMessage: string;\n  \n  if (hasChildItems) {\n    const folderCount = item.children?.filter(child => child.is_folder).length || 0;\n    const cardCount = item.children?.filter(child => !child.is_folder).length || 0;\n    \n    let itemDescription = '';\n    if (folderCount > 0 && cardCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'} and ${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    } else if (folderCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'}`;\n    } else {\n      itemDescription = `${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    }\n    \n    confirmMessage = `This ${item.is_folder ? 'folder' : 'category'} contains ${itemDescription}. Deleting it will also delete all items inside. Do you want to continue?`;\n  } else {\n    confirmMessage = `Are you sure you want to delete this ${item.is_folder ? 'folder' : 'card'}?`;\n  }\n\n  const confirmed = window.confirm(confirmMessage);\n  \n  if (!confirmed) {\n    return;\n  }\n\n  try {\n    if (hasChildItems) {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'category'} with children recursively:`, item.id, item.name);\n      // Delete all children first (recursively)\n      await deleteChildrenRecursively(item.children || []);\n      // Then delete the parent\n      console.log(`Deleting parent ${item.is_folder ? 'folder' : 'category'}:`, item.id, item.name);\n      await apiClient.deleteCard(item.id);\n    } else {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'card'} without children using standard delete:`, item.id, item.name);\n      await apiClient.deleteCard(item.id);\n    }\n    onSuccess();\n  } catch (error: any) {\n    console.error('Error deleting item:', error);\n    \n    // Handle specific error cases\n    if (error?.response?.status === 404) {\n      // Item not found - might have been deleted already\n      console.warn(`Item ${item.id} not found, might have been deleted already`);\n      // Still call onSuccess to update the UI since the item is effectively gone\n      onSuccess();\n      return;\n    }\n    \n    if (onError) {\n      onError(error);\n    } else {\n      const errorMessage = error?.response?.data?.detail || error?.message || 'Unknown error occurred';\n      const statusCode = error?.response?.status;\n      \n      if (statusCode === 404) {\n        alert(`The ${item.is_folder ? 'folder' : 'card'} was not found. It may have been deleted already.`);\n      } else {\n        alert(`Failed to delete ${item.is_folder ? 'folder' : 'card'}: ${errorMessage}`);\n      }\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}