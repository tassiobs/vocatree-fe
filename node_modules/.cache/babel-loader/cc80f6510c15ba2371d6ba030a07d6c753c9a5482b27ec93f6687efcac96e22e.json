{"ast":null,"code":"import { apiClient } from '../services/api';\n\n/**\n * Check if a tree item has children (cards or folders)\n */\nexport const hasChildren = item => {\n  return item.children && item.children.length > 0;\n};\n\n/**\n * Get the count of children for a tree item\n */\nexport const getChildrenCount = item => {\n  return item.children ? item.children.length : 0;\n};\n\n/**\n * Recursively delete all children of a tree item\n */\nconst deleteChildrenRecursively = async children => {\n  for (const child of children) {\n    // If child has children, delete them first\n    if (hasChildren(child)) {\n      await deleteChildrenRecursively(child.children || []);\n    }\n    // Delete the child itself\n    await apiClient.deleteCard(child.id);\n  }\n};\n\n/**\n * Handle conditional delete for a tree item\n * Shows appropriate confirmation message based on whether the item has children\n */\nexport const handleConditionalDelete = async (item, onSuccess, onError) => {\n  const hasChildItems = hasChildren(item);\n  const childrenCount = getChildrenCount(item);\n  let confirmMessage;\n  if (hasChildItems) {\n    var _item$children, _item$children2;\n    const folderCount = ((_item$children = item.children) === null || _item$children === void 0 ? void 0 : _item$children.filter(child => child.is_folder).length) || 0;\n    const cardCount = ((_item$children2 = item.children) === null || _item$children2 === void 0 ? void 0 : _item$children2.filter(child => !child.is_folder).length) || 0;\n    let itemDescription = '';\n    if (folderCount > 0 && cardCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'} and ${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    } else if (folderCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'}`;\n    } else {\n      itemDescription = `${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    }\n    confirmMessage = `This ${item.is_folder ? 'folder' : 'category'} contains ${itemDescription}. Deleting it will also delete all items inside. Do you want to continue?`;\n  } else {\n    confirmMessage = `Are you sure you want to delete this ${item.is_folder ? 'folder' : 'card'}?`;\n  }\n  const confirmed = window.confirm(confirmMessage);\n  if (!confirmed) {\n    return;\n  }\n  try {\n    if (hasChildItems) {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'category'} with children recursively:`, item.id);\n      // Delete all children first (recursively)\n      await deleteChildrenRecursively(item.children || []);\n      // Then delete the parent\n      await apiClient.deleteCard(item.id);\n    } else {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'card'} without children using standard delete:`, item.id);\n      await apiClient.deleteCard(item.id);\n    }\n    onSuccess();\n  } catch (error) {\n    var _error$response;\n    console.error('Error deleting item:', error);\n\n    // Handle specific error cases\n    if ((error === null || error === void 0 ? void 0 : (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 404) {\n      // Item not found - might have been deleted already\n      console.warn(`Item ${item.id} not found, might have been deleted already`);\n      // Still call onSuccess to update the UI since the item is effectively gone\n      onSuccess();\n      return;\n    }\n    if (onError) {\n      onError(error);\n    } else {\n      var _error$response2, _error$response2$data, _error$response3;\n      const errorMessage = (error === null || error === void 0 ? void 0 : (_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : (_error$response2$data = _error$response2.data) === null || _error$response2$data === void 0 ? void 0 : _error$response2$data.detail) || (error === null || error === void 0 ? void 0 : error.message) || 'Unknown error occurred';\n      const statusCode = error === null || error === void 0 ? void 0 : (_error$response3 = error.response) === null || _error$response3 === void 0 ? void 0 : _error$response3.status;\n      if (statusCode === 404) {\n        alert(`The ${item.is_folder ? 'folder' : 'card'} was not found. It may have been deleted already.`);\n      } else {\n        alert(`Failed to delete ${item.is_folder ? 'folder' : 'card'}: ${errorMessage}`);\n      }\n    }\n  }\n};","map":{"version":3,"names":["apiClient","hasChildren","item","children","length","getChildrenCount","deleteChildrenRecursively","child","deleteCard","id","handleConditionalDelete","onSuccess","onError","hasChildItems","childrenCount","confirmMessage","_item$children","_item$children2","folderCount","filter","is_folder","cardCount","itemDescription","confirmed","window","confirm","console","log","error","_error$response","response","status","warn","_error$response2","_error$response2$data","_error$response3","errorMessage","data","detail","message","statusCode","alert"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/utils/deleteUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { apiClient } from '../services/api';\n\n/**\n * Check if a tree item has children (cards or folders)\n */\nexport const hasChildren = (item: TreeItem): boolean => {\n  return item.children && item.children.length > 0;\n};\n\n/**\n * Get the count of children for a tree item\n */\nexport const getChildrenCount = (item: TreeItem): number => {\n  return item.children ? item.children.length : 0;\n};\n\n/**\n * Recursively delete all children of a tree item\n */\nconst deleteChildrenRecursively = async (children: TreeItem[]): Promise<void> => {\n  for (const child of children) {\n    // If child has children, delete them first\n    if (hasChildren(child)) {\n      await deleteChildrenRecursively(child.children || []);\n    }\n    // Delete the child itself\n    await apiClient.deleteCard(child.id);\n  }\n};\n\n/**\n * Handle conditional delete for a tree item\n * Shows appropriate confirmation message based on whether the item has children\n */\nexport const handleConditionalDelete = async (\n  item: TreeItem,\n  onSuccess: () => void,\n  onError?: (error: any) => void\n): Promise<void> => {\n  const hasChildItems = hasChildren(item);\n  const childrenCount = getChildrenCount(item);\n  \n  let confirmMessage: string;\n  \n  if (hasChildItems) {\n    const folderCount = item.children?.filter(child => child.is_folder).length || 0;\n    const cardCount = item.children?.filter(child => !child.is_folder).length || 0;\n    \n    let itemDescription = '';\n    if (folderCount > 0 && cardCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'} and ${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    } else if (folderCount > 0) {\n      itemDescription = `${folderCount} folder${folderCount === 1 ? '' : 's'}`;\n    } else {\n      itemDescription = `${cardCount} card${cardCount === 1 ? '' : 's'}`;\n    }\n    \n    confirmMessage = `This ${item.is_folder ? 'folder' : 'category'} contains ${itemDescription}. Deleting it will also delete all items inside. Do you want to continue?`;\n  } else {\n    confirmMessage = `Are you sure you want to delete this ${item.is_folder ? 'folder' : 'card'}?`;\n  }\n\n  const confirmed = window.confirm(confirmMessage);\n  \n  if (!confirmed) {\n    return;\n  }\n\n  try {\n    if (hasChildItems) {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'category'} with children recursively:`, item.id);\n      // Delete all children first (recursively)\n      await deleteChildrenRecursively(item.children || []);\n      // Then delete the parent\n      await apiClient.deleteCard(item.id);\n    } else {\n      console.log(`Deleting ${item.is_folder ? 'folder' : 'card'} without children using standard delete:`, item.id);\n      await apiClient.deleteCard(item.id);\n    }\n    onSuccess();\n  } catch (error: any) {\n    console.error('Error deleting item:', error);\n    \n    // Handle specific error cases\n    if (error?.response?.status === 404) {\n      // Item not found - might have been deleted already\n      console.warn(`Item ${item.id} not found, might have been deleted already`);\n      // Still call onSuccess to update the UI since the item is effectively gone\n      onSuccess();\n      return;\n    }\n    \n    if (onError) {\n      onError(error);\n    } else {\n      const errorMessage = error?.response?.data?.detail || error?.message || 'Unknown error occurred';\n      const statusCode = error?.response?.status;\n      \n      if (statusCode === 404) {\n        alert(`The ${item.is_folder ? 'folder' : 'card'} was not found. It may have been deleted already.`);\n      } else {\n        alert(`Failed to delete ${item.is_folder ? 'folder' : 'card'}: ${errorMessage}`);\n      }\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}