{"ast":null,"code":"import{createContext,useContext,useState,useEffect,useCallback}from'react';import{apiClient}from'../services/api';import{jsx as _jsx}from\"react/jsx-runtime\";const AuthContext=/*#__PURE__*/createContext(undefined);export const useAuth=()=>{const context=useContext(AuthContext);if(!context){throw new Error('useAuth must be used within an AuthProvider');}return context;};export const AuthProvider=_ref=>{let{children}=_ref;const[user,setUser]=useState(null);const[isLoading,setIsLoading]=useState(true);const[isAuthenticated,setIsAuthenticated]=useState(false);// Handle auth failure (when refresh fails)\nconst handleAuthFailure=useCallback(()=>{setUser(null);setIsAuthenticated(false);},[]);// Check authentication status on mount and when needed\n// This enables \"close tab ‚Üí come back days later ‚Üí still logged in\" (if refresh token is valid within 7 days)\nconst checkAuth=useCallback(async()=>{try{// Try to get current user info\n// If access token is still valid (within ~30 minutes), this succeeds\nconst userData=await apiClient.getMe();// User is authenticated\nsetUser({id:userData.id,email:userData.email,created_at:new Date().toISOString()});setIsAuthenticated(true);return true;}catch(error){var _error$response;// If 401, access token expired - try to refresh using refresh token\n// This handles: user closed tab hours/days ago, refresh token still valid (within 7 days)\nif(((_error$response=error.response)===null||_error$response===void 0?void 0:_error$response.status)===401){try{// Attempt to refresh the access token using refresh token cookie\n// Refresh endpoint rotates refresh token, extending the 7-day window\nawait apiClient.refresh();// Refresh succeeded - get user info with new access token\nconst userData=await apiClient.getMe();setUser({id:userData.id,email:userData.email,created_at:new Date().toISOString()});setIsAuthenticated(true);return true;}catch(refreshError){// Refresh failed - refresh token expired (>7 days) or doesn't exist\n// User needs to log in again\nsetUser(null);setIsAuthenticated(false);return false;}}// Other errors (network, etc.)\nsetUser(null);setIsAuthenticated(false);return false;}},[]);// Check auth status on mount (including when user returns after days)\n// This handles the \"close tab ‚Üí come back later ‚Üí still logged in\" scenario\n// Flow: Try /auth/me ‚Üí if 401 (expired), try /auth/refresh ‚Üí if refresh succeeds (refresh token valid within 7 days), user stays logged in\nuseEffect(()=>{checkAuth().finally(()=>{setIsLoading(false);});},[checkAuth]);// Set auth failure callback on API client\nuseEffect(()=>{apiClient.setOnAuthFailure(handleAuthFailure);},[handleAuthFailure]);const login=async(email,password)=>{try{// Sign in - cookies are set by backend automatically\nconsole.log('üîë Step 1: Calling /auth/signin...');await apiClient.signIn({email,password});console.log('‚úÖ Step 1 complete: Signin successful, cookies should be set');// Verify auth by calling /auth/me (backend requirement)\n// Wait for cookies to be processed by browser\n// Cross-origin cookies may need more time to be set\nconsole.log('‚è≥ Step 2: Waiting for cookies to be processed...');await new Promise(resolve=>setTimeout(resolve,1000));// Debug: Try to call debug endpoint to verify cookies are being sent\ntry{console.log('üîç Step 2.5: Testing if cookies are being sent...');const cookieDebug=await apiClient.debugCookies();console.log('‚úÖ Cookie debug result (backend received cookies):',cookieDebug);}catch(debugError){var _debugError$response,_debugError$response2;console.error('‚ùå Cookie debug failed:',{status:(_debugError$response=debugError.response)===null||_debugError$response===void 0?void 0:_debugError$response.status,data:(_debugError$response2=debugError.response)===null||_debugError$response2===void 0?void 0:_debugError$response2.data});console.error('‚ö†Ô∏è This suggests cookies are NOT being sent with requests!');console.error('‚ö†Ô∏è DIAGNOSIS: Check Network tab ‚Üí /auth/me request ‚Üí Request Headers');console.error('‚ö†Ô∏è If there is NO \"Cookie:\" header, cookies are not being sent');console.error('‚ö†Ô∏è SOLUTION: Backend MUST set cookies with SameSite=None; Secure (not SameSite=lax)');}// Get user info after successful login\nconsole.log('üîë Step 3: Calling /auth/me to verify authentication...');const userData=await apiClient.getMe();console.log('‚úÖ Step 3 complete: Got user info:',userData);setUser({id:userData.id,email:userData.email,created_at:new Date().toISOString()});setIsAuthenticated(true);}catch(error){var _error$response2,_error$response3;console.error('‚ùå Login failed:',{message:error.message,status:(_error$response2=error.response)===null||_error$response2===void 0?void 0:_error$response2.status,data:(_error$response3=error.response)===null||_error$response3===void 0?void 0:_error$response3.data,step:'Check Network tab ‚Üí /auth/me request ‚Üí Request Headers ‚Üí Cookie: header'});setUser(null);setIsAuthenticated(false);throw error;}};const logout=useCallback(async()=>{try{// Call logout endpoint to clear cookies on backend\nawait apiClient.logout();}catch(error){console.warn('Logout endpoint error:',error);}finally{// Clear local state regardless\nsetUser(null);setIsAuthenticated(false);}},[]);const value={user,token:user!==null?'cookie':null,// Keep token for compatibility, using cookie authentication\nlogin,logout,isLoading};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:value,children:children});};","map":{"version":3,"names":["createContext","useContext","useState","useEffect","useCallback","apiClient","jsx","_jsx","AuthContext","undefined","useAuth","context","Error","AuthProvider","_ref","children","user","setUser","isLoading","setIsLoading","isAuthenticated","setIsAuthenticated","handleAuthFailure","checkAuth","userData","getMe","id","email","created_at","Date","toISOString","error","_error$response","response","status","refresh","refreshError","finally","setOnAuthFailure","login","password","console","log","signIn","Promise","resolve","setTimeout","cookieDebug","debugCookies","debugError","_debugError$response","_debugError$response2","data","_error$response2","_error$response3","message","step","logout","warn","value","token","Provider"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/hooks/useAuth.tsx"],"sourcesContent":["import { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';\nimport { User, AuthContextType } from '../types';\nimport { apiClient } from '../services/api';\nimport { AuthMeResponse } from '../types/api';\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  if (!context) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n};\n\ninterface AuthProviderProps {\n  children: ReactNode;\n}\n\nexport const AuthProvider = ({ children }: AuthProviderProps) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [isAuthenticated, setIsAuthenticated] = useState(false);\n\n  // Handle auth failure (when refresh fails)\n  const handleAuthFailure = useCallback(() => {\n    setUser(null);\n    setIsAuthenticated(false);\n  }, []);\n\n  // Check authentication status on mount and when needed\n  // This enables \"close tab ‚Üí come back days later ‚Üí still logged in\" (if refresh token is valid within 7 days)\n  const checkAuth = useCallback(async () => {\n    try {\n      // Try to get current user info\n      // If access token is still valid (within ~30 minutes), this succeeds\n      const userData = await apiClient.getMe();\n      \n      // User is authenticated\n      setUser({\n        id: userData.id,\n        email: userData.email,\n        created_at: new Date().toISOString(),\n      });\n      setIsAuthenticated(true);\n      return true;\n    } catch (error: any) {\n      // If 401, access token expired - try to refresh using refresh token\n      // This handles: user closed tab hours/days ago, refresh token still valid (within 7 days)\n      if (error.response?.status === 401) {\n        try {\n          // Attempt to refresh the access token using refresh token cookie\n          // Refresh endpoint rotates refresh token, extending the 7-day window\n          await apiClient.refresh();\n          \n          // Refresh succeeded - get user info with new access token\n          const userData = await apiClient.getMe();\n          setUser({\n            id: userData.id,\n            email: userData.email,\n            created_at: new Date().toISOString(),\n          });\n          setIsAuthenticated(true);\n          return true;\n        } catch (refreshError: any) {\n          // Refresh failed - refresh token expired (>7 days) or doesn't exist\n          // User needs to log in again\n          setUser(null);\n          setIsAuthenticated(false);\n          return false;\n        }\n      }\n      \n      // Other errors (network, etc.)\n      setUser(null);\n      setIsAuthenticated(false);\n      return false;\n    }\n  }, []);\n\n  // Check auth status on mount (including when user returns after days)\n  // This handles the \"close tab ‚Üí come back later ‚Üí still logged in\" scenario\n  // Flow: Try /auth/me ‚Üí if 401 (expired), try /auth/refresh ‚Üí if refresh succeeds (refresh token valid within 7 days), user stays logged in\n  useEffect(() => {\n    checkAuth().finally(() => {\n      setIsLoading(false);\n    });\n  }, [checkAuth]);\n\n  // Set auth failure callback on API client\n  useEffect(() => {\n    apiClient.setOnAuthFailure(handleAuthFailure);\n  }, [handleAuthFailure]);\n\n  const login = async (email: string, password: string): Promise<void> => {\n    try {\n      // Sign in - cookies are set by backend automatically\n      console.log('üîë Step 1: Calling /auth/signin...');\n      await apiClient.signIn({ email, password });\n      console.log('‚úÖ Step 1 complete: Signin successful, cookies should be set');\n      \n      // Verify auth by calling /auth/me (backend requirement)\n      // Wait for cookies to be processed by browser\n      // Cross-origin cookies may need more time to be set\n      console.log('‚è≥ Step 2: Waiting for cookies to be processed...');\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      \n      // Debug: Try to call debug endpoint to verify cookies are being sent\n      try {\n        console.log('üîç Step 2.5: Testing if cookies are being sent...');\n        const cookieDebug = await apiClient.debugCookies();\n        console.log('‚úÖ Cookie debug result (backend received cookies):', cookieDebug);\n      } catch (debugError: any) {\n        console.error('‚ùå Cookie debug failed:', {\n          status: debugError.response?.status,\n          data: debugError.response?.data,\n        });\n        console.error('‚ö†Ô∏è This suggests cookies are NOT being sent with requests!');\n        console.error('‚ö†Ô∏è DIAGNOSIS: Check Network tab ‚Üí /auth/me request ‚Üí Request Headers');\n        console.error('‚ö†Ô∏è If there is NO \"Cookie:\" header, cookies are not being sent');\n        console.error('‚ö†Ô∏è SOLUTION: Backend MUST set cookies with SameSite=None; Secure (not SameSite=lax)');\n      }\n      \n      // Get user info after successful login\n      console.log('üîë Step 3: Calling /auth/me to verify authentication...');\n      const userData = await apiClient.getMe();\n      console.log('‚úÖ Step 3 complete: Got user info:', userData);\n      \n      setUser({\n        id: userData.id,\n        email: userData.email,\n        created_at: new Date().toISOString(),\n      });\n      setIsAuthenticated(true);\n    } catch (error: any) {\n      console.error('‚ùå Login failed:', {\n        message: error.message,\n        status: error.response?.status,\n        data: error.response?.data,\n        step: 'Check Network tab ‚Üí /auth/me request ‚Üí Request Headers ‚Üí Cookie: header',\n      });\n      setUser(null);\n      setIsAuthenticated(false);\n      throw error;\n    }\n  };\n\n  const logout = useCallback(async (): Promise<void> => {\n    try {\n      // Call logout endpoint to clear cookies on backend\n      await apiClient.logout();\n    } catch (error) {\n      console.warn('Logout endpoint error:', error);\n    } finally {\n      // Clear local state regardless\n      setUser(null);\n      setIsAuthenticated(false);\n    }\n  }, []);\n\n  const value: AuthContextType = {\n    user,\n    token: user !== null ? 'cookie' : null, // Keep token for compatibility, using cookie authentication\n    login,\n    logout,\n    isLoading,\n  };\n\n  return (\n    <AuthContext.Provider value={value}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}