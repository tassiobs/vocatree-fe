{"ast":null,"code":"import _objectSpread from\"/Users/tassiobs/Documents/vocatree-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem=card=>{const children=card.children&&card.children.length>0?card.children.map(childCard=>cardToTreeItem(childCard)):[];return{id:card.id,name:card.name,type:card.is_folder?'folder':'card',parent_id:card.parent_id,is_folder:card.is_folder,children:children,isExpanded:false,// Start collapsed\nexample_phrases:card.example_phrases,meanings:card.meanings,grammar_roles:card.grammar_roles,collocations:card.collocations,synonyms:card.synonyms,antonyms:card.antonyms,use_count:card.use_count,notes:card.notes,created_at:card.created_at,user_created:card.user_created};};// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree=(cards,expandedIds)=>{// The /cards/hierarchy endpoint returns cards with children already populated\n// So we just need to recursively convert them to TreeItems\nconst cardToTreeItemWithExpanded=card=>{const children=card.children&&card.children.length>0?card.children.map(childCard=>cardToTreeItemWithExpanded(childCard)):[];return{id:card.id,name:card.name,type:card.is_folder?'folder':'card',parent_id:card.parent_id,is_folder:card.is_folder,children:children,isExpanded:expandedIds?expandedIds.has(card.id):false,// Preserve expanded state\nexample_phrases:card.example_phrases,meanings:card.meanings,grammar_roles:card.grammar_roles,collocations:card.collocations,synonyms:card.synonyms,antonyms:card.antonyms,use_count:card.use_count,notes:card.notes,created_at:card.created_at,user_created:card.user_created};};const treeItems=cards.map(card=>cardToTreeItemWithExpanded(card));// Sort children by name\nconst sortChildren=items=>{items.sort((a,b)=>{// Folders first, then cards\nif(a.type!==b.type){return a.type==='folder'?-1:1;}return a.name.localeCompare(b.name);});items.forEach(item=>{if(item.children.length>0){sortChildren(item.children);}});};sortChildren(treeItems);return treeItems;};// Find item in tree by ID\nexport const findTreeItem=(tree,id)=>{for(const item of tree){if(item.id===id){return item;}const found=findTreeItem(item.children,id);if(found){return found;}}return null;};// Update item in tree\nexport const updateTreeItem=(tree,id,updates)=>{return tree.map(item=>{if(item.id===id){return _objectSpread(_objectSpread({},item),updates);}if(item.children.length>0){return _objectSpread(_objectSpread({},item),{},{children:updateTreeItem(item.children,id,updates)});}return item;});};// Remove item from tree\nexport const removeTreeItem=(tree,id)=>{return tree.filter(item=>{if(item.id===id){return false;}if(item.children.length>0){item.children=removeTreeItem(item.children,id);}return true;});};// Move item to new parent\nexport const moveTreeItem=(tree,itemId,newParentId)=>{// Find the item to move\nconst itemToMove=findTreeItem(tree,itemId);if(!itemToMove){return tree;}// Remove from current location\nlet updatedTree=removeTreeItem(tree,itemId);// Update item's parent_id\nitemToMove.parent_id=newParentId;// Add to new location\nif(newParentId===null){// Moving to root\nupdatedTree.push(itemToMove);}else{var _findTreeItem;// Moving to a parent\nupdatedTree=updateTreeItem(updatedTree,newParentId,{children:[...(((_findTreeItem=findTreeItem(updatedTree,newParentId))===null||_findTreeItem===void 0?void 0:_findTreeItem.children)||[]),itemToMove]});}return updatedTree;};// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds=(tree,itemId)=>{const findParentIds=(items,targetId,currentPath)=>{for(const item of items){const newPath=[...currentPath,item.id];if(item.id===targetId){return currentPath;// Return path without the target item itself\n}if(item.children.length>0){const result=findParentIds(item.children,targetId,newPath);if(result){return result;}}}return null;};return findParentIds(tree,itemId,[])||[];};// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree=tree=>{const result=[];const traverse=items=>{items.forEach(item=>{result.push(item);if(item.children.length>0){traverse(item.children);}});};traverse(tree);return result;};// Get all expanded item IDs from a tree\nexport const getExpandedIds=tree=>{const expandedIds=new Set();const traverse=items=>{items.forEach(item=>{if(item.isExpanded){expandedIds.add(item.id);}if(item.children.length>0){traverse(item.children);}});};traverse(tree);return expandedIds;};// Move item across categories or within a category\n// This function handles both moving within a category and moving between categories\nexport const moveItemAcrossCategories=(categories,itemId,newParentId,newCategoryId)=>{// Find the item across all categories\nlet itemToMove=null;let sourceCategoryIndex=-1;for(let i=0;i<categories.length;i++){const found=findTreeItem(categories[i].children,itemId);if(found){itemToMove=found;sourceCategoryIndex=i;break;}}if(!itemToMove||sourceCategoryIndex===-1){return categories;}// Create a copy of the item with updated parent_id and category_id\nconst updatedItem=_objectSpread(_objectSpread({},itemToMove),{},{parent_id:newParentId,category_id:newCategoryId!==null?newCategoryId:itemToMove.category_id});// Remove from source category\nconst updatedCategories=categories.map((category,index)=>{if(index===sourceCategoryIndex){return _objectSpread(_objectSpread({},category),{},{children:removeTreeItem(category.children,itemId)});}return category;});// Add to target category\nconst targetCategoryIndex=newCategoryId!==null?updatedCategories.findIndex(cat=>cat.id===newCategoryId):sourceCategoryIndex;// If no category_id specified, stay in same category\nif(targetCategoryIndex===-1){// Target category not found, return original\nreturn categories;}// Add item to target location\nif(newParentId===null){// Moving to root of target category\nupdatedCategories[targetCategoryIndex]=_objectSpread(_objectSpread({},updatedCategories[targetCategoryIndex]),{},{children:[...updatedCategories[targetCategoryIndex].children,updatedItem]});}else{// Moving to a specific folder in target category\nconst targetCategory=updatedCategories[targetCategoryIndex];const parentItem=findTreeItem(targetCategory.children,newParentId);if(parentItem){// Update the parent's children\nupdatedCategories[targetCategoryIndex]=_objectSpread(_objectSpread({},targetCategory),{},{children:updateTreeItem(targetCategory.children,newParentId,{children:[...(parentItem.children||[]),updatedItem]})});}else{// Parent not found, add to root as fallback\nupdatedCategories[targetCategoryIndex]=_objectSpread(_objectSpread({},targetCategory),{},{children:[...targetCategory.children,updatedItem]});}}return updatedCategories;};","map":{"version":3,"names":["cardToTreeItem","card","children","length","map","childCard","id","name","type","is_folder","parent_id","isExpanded","example_phrases","meanings","grammar_roles","collocations","synonyms","antonyms","use_count","notes","created_at","user_created","buildTree","cards","expandedIds","cardToTreeItemWithExpanded","has","treeItems","sortChildren","items","sort","a","b","localeCompare","forEach","item","findTreeItem","tree","found","updateTreeItem","updates","_objectSpread","removeTreeItem","filter","moveTreeItem","itemId","newParentId","itemToMove","updatedTree","push","_findTreeItem","getParentIds","findParentIds","targetId","currentPath","newPath","result","flattenTree","traverse","getExpandedIds","Set","add","moveItemAcrossCategories","categories","newCategoryId","sourceCategoryIndex","i","updatedItem","category_id","updatedCategories","category","index","targetCategoryIndex","findIndex","cat","targetCategory","parentItem"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/utils/treeUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { Card } from '../types/api';\n\n// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = (card: Card): TreeItem => {\n  const children = card.children && card.children.length > 0 \n    ? card.children.map(childCard => cardToTreeItem(childCard))\n    : [];\n  \n  return {\n    id: card.id,\n    name: card.name,\n    type: card.is_folder ? 'folder' : 'card',\n    parent_id: card.parent_id,\n    is_folder: card.is_folder,\n    children: children,\n    isExpanded: false, // Start collapsed\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created,\n  };\n};\n\n// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree = (cards: Card[], expandedIds?: Set<number>): TreeItem[] => {\n  // The /cards/hierarchy endpoint returns cards with children already populated\n  // So we just need to recursively convert them to TreeItems\n  const cardToTreeItemWithExpanded = (card: Card): TreeItem => {\n    const children = card.children && card.children.length > 0 \n      ? card.children.map(childCard => cardToTreeItemWithExpanded(childCard))\n      : [];\n    \n    return {\n      id: card.id,\n      name: card.name,\n      type: card.is_folder ? 'folder' : 'card',\n      parent_id: card.parent_id,\n      is_folder: card.is_folder,\n      children: children,\n      isExpanded: expandedIds ? expandedIds.has(card.id) : false, // Preserve expanded state\n      example_phrases: card.example_phrases,\n      meanings: card.meanings,\n      grammar_roles: card.grammar_roles,\n      collocations: card.collocations,\n      synonyms: card.synonyms,\n      antonyms: card.antonyms,\n      use_count: card.use_count,\n      notes: card.notes,\n      created_at: card.created_at,\n      user_created: card.user_created,\n    };\n  };\n\n  const treeItems = cards.map(card => cardToTreeItemWithExpanded(card));\n  \n  // Sort children by name\n  const sortChildren = (items: TreeItem[]) => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    \n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n\n  sortChildren(treeItems);\n  return treeItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree: TreeItem[], id: number): TreeItem | null => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree: TreeItem[], id: number, updates: Partial<TreeItem>): TreeItem[] => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return { ...item, ...updates };\n    }\n    if (item.children.length > 0) {\n      return { ...item, children: updateTreeItem(item.children, id, updates) };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree: TreeItem[], id: number): TreeItem[] => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (\n  tree: TreeItem[], \n  itemId: number, \n  newParentId: number | null\n): TreeItem[] => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n  \n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(findTreeItem(updatedTree, newParentId)?.children || []), itemToMove]\n    });\n  }\n\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree: TreeItem[], itemId: number): number[] => {\n  const findParentIds = (items: TreeItem[], targetId: number, currentPath: number[]): number[] | null => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      \n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      \n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = (tree: TreeItem[]): TreeItem[] => {\n  const result: TreeItem[] = [];\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return result;\n};\n\n// Get all expanded item IDs from a tree\nexport const getExpandedIds = (tree: TreeItem[]): Set<number> => {\n  const expandedIds = new Set<number>();\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      if (item.isExpanded) {\n        expandedIds.add(item.id);\n      }\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return expandedIds;\n};\n\n// Move item across categories or within a category\n// This function handles both moving within a category and moving between categories\nexport const moveItemAcrossCategories = (\n  categories: Array<{ id: number; children: TreeItem[] }>,\n  itemId: number,\n  newParentId: number | null,\n  newCategoryId: number | null\n): Array<{ id: number; children: TreeItem[] }> => {\n  // Find the item across all categories\n  let itemToMove: TreeItem | null = null;\n  let sourceCategoryIndex = -1;\n  \n  for (let i = 0; i < categories.length; i++) {\n    const found = findTreeItem(categories[i].children, itemId);\n    if (found) {\n      itemToMove = found;\n      sourceCategoryIndex = i;\n      break;\n    }\n  }\n  \n  if (!itemToMove || sourceCategoryIndex === -1) {\n    return categories;\n  }\n  \n  // Create a copy of the item with updated parent_id and category_id\n  const updatedItem: TreeItem = {\n    ...itemToMove,\n    parent_id: newParentId,\n    category_id: newCategoryId !== null ? newCategoryId : itemToMove.category_id,\n  };\n  \n  // Remove from source category\n  const updatedCategories = categories.map((category, index) => {\n    if (index === sourceCategoryIndex) {\n      return {\n        ...category,\n        children: removeTreeItem(category.children, itemId),\n      };\n    }\n    return category;\n  });\n  \n  // Add to target category\n  const targetCategoryIndex = newCategoryId !== null \n    ? updatedCategories.findIndex(cat => cat.id === newCategoryId)\n    : sourceCategoryIndex; // If no category_id specified, stay in same category\n  \n  if (targetCategoryIndex === -1) {\n    // Target category not found, return original\n    return categories;\n  }\n  \n  // Add item to target location\n  if (newParentId === null) {\n    // Moving to root of target category\n    updatedCategories[targetCategoryIndex] = {\n      ...updatedCategories[targetCategoryIndex],\n      children: [...updatedCategories[targetCategoryIndex].children, updatedItem],\n    };\n  } else {\n    // Moving to a specific folder in target category\n    const targetCategory = updatedCategories[targetCategoryIndex];\n    const parentItem = findTreeItem(targetCategory.children, newParentId);\n    if (parentItem) {\n      // Update the parent's children\n      updatedCategories[targetCategoryIndex] = {\n        ...targetCategory,\n        children: updateTreeItem(targetCategory.children, newParentId, {\n          children: [...(parentItem.children || []), updatedItem],\n        }),\n      };\n    } else {\n      // Parent not found, add to root as fallback\n      updatedCategories[targetCategoryIndex] = {\n        ...targetCategory,\n        children: [...targetCategory.children, updatedItem],\n      };\n    }\n  }\n  \n  return updatedCategories;\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}