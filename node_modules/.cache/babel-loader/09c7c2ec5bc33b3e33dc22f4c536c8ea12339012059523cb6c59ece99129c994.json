{"ast":null,"code":"import _objectSpread from\"/Users/tassiobs/Documents/vocatree-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem=card=>{const children=card.children&&card.children.length>0?card.children.map(childCard=>cardToTreeItem(childCard)):[];return{id:card.id,name:card.name,type:card.is_folder?'folder':'card',parent_id:card.parent_id,is_folder:card.is_folder,children:children,isExpanded:false,// Start collapsed\nexample_phrases:card.example_phrases,meanings:card.meanings,grammar_roles:card.grammar_roles,collocations:card.collocations,synonyms:card.synonyms,antonyms:card.antonyms,use_count:card.use_count,notes:card.notes,created_at:card.created_at,user_created:card.user_created};};// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree=(cards,expandedIds)=>{// The /cards/hierarchy endpoint returns cards with children already populated\n// So we just need to recursively convert them to TreeItems\nconst cardToTreeItemWithExpanded=card=>{const children=card.children&&card.children.length>0?card.children.map(childCard=>cardToTreeItemWithExpanded(childCard)):[];return{id:card.id,name:card.name,type:card.is_folder?'folder':'card',parent_id:card.parent_id,is_folder:card.is_folder,children:children,isExpanded:expandedIds?expandedIds.has(card.id):false,// Preserve expanded state\nexample_phrases:card.example_phrases,meanings:card.meanings,grammar_roles:card.grammar_roles,collocations:card.collocations,synonyms:card.synonyms,antonyms:card.antonyms,use_count:card.use_count,notes:card.notes,created_at:card.created_at,user_created:card.user_created};};const treeItems=cards.map(card=>cardToTreeItemWithExpanded(card));// Sort children by name\nconst sortChildren=items=>{items.sort((a,b)=>{// Folders first, then cards\nif(a.type!==b.type){return a.type==='folder'?-1:1;}return a.name.localeCompare(b.name);});items.forEach(item=>{if(item.children.length>0){sortChildren(item.children);}});};sortChildren(treeItems);return treeItems;};// Find item in tree by ID\nexport const findTreeItem=(tree,id)=>{for(const item of tree){if(item.id===id){return item;}const found=findTreeItem(item.children,id);if(found){return found;}}return null;};// Update item in tree\nexport const updateTreeItem=(tree,id,updates)=>{return tree.map(item=>{if(item.id===id){return _objectSpread(_objectSpread({},item),updates);}if(item.children.length>0){return _objectSpread(_objectSpread({},item),{},{children:updateTreeItem(item.children,id,updates)});}return item;});};// Remove item from tree\nexport const removeTreeItem=(tree,id)=>{return tree.filter(item=>{if(item.id===id){return false;}if(item.children.length>0){item.children=removeTreeItem(item.children,id);}return true;});};// Move item to new parent\nexport const moveTreeItem=(tree,itemId,newParentId)=>{// Find the item to move\nconst itemToMove=findTreeItem(tree,itemId);if(!itemToMove){return tree;}// Remove from current location\nlet updatedTree=removeTreeItem(tree,itemId);// Update item's parent_id\nitemToMove.parent_id=newParentId;// Add to new location\nif(newParentId===null){// Moving to root\nupdatedTree.push(itemToMove);}else{var _findTreeItem;// Moving to a parent\nupdatedTree=updateTreeItem(updatedTree,newParentId,{children:[...(((_findTreeItem=findTreeItem(updatedTree,newParentId))===null||_findTreeItem===void 0?void 0:_findTreeItem.children)||[]),itemToMove]});}return updatedTree;};// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds=(tree,itemId)=>{const findParentIds=(items,targetId,currentPath)=>{for(const item of items){const newPath=[...currentPath,item.id];if(item.id===targetId){return currentPath;// Return path without the target item itself\n}if(item.children.length>0){const result=findParentIds(item.children,targetId,newPath);if(result){return result;}}}return null;};return findParentIds(tree,itemId,[])||[];};// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree=tree=>{const result=[];const traverse=items=>{items.forEach(item=>{result.push(item);if(item.children.length>0){traverse(item.children);}});};traverse(tree);return result;};// Get all expanded item IDs from a tree\nexport const getExpandedIds=tree=>{const expandedIds=new Set();const traverse=items=>{items.forEach(item=>{if(item.isExpanded){expandedIds.add(item.id);}if(item.children.length>0){traverse(item.children);}});};traverse(tree);return expandedIds;};","map":{"version":3,"names":["cardToTreeItem","card","children","length","map","childCard","id","name","type","is_folder","parent_id","isExpanded","example_phrases","meanings","grammar_roles","collocations","synonyms","antonyms","use_count","notes","created_at","user_created","buildTree","cards","expandedIds","cardToTreeItemWithExpanded","has","treeItems","sortChildren","items","sort","a","b","localeCompare","forEach","item","findTreeItem","tree","found","updateTreeItem","updates","_objectSpread","removeTreeItem","filter","moveTreeItem","itemId","newParentId","itemToMove","updatedTree","push","_findTreeItem","getParentIds","findParentIds","targetId","currentPath","newPath","result","flattenTree","traverse","getExpandedIds","Set","add"],"sources":["/Users/tassiobs/Documents/vocatree-fe/src/utils/treeUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { Card } from '../types/api';\n\n// Convert API Card to TreeItem (recursively handles children)\nexport const cardToTreeItem = (card: Card): TreeItem => {\n  const children = card.children && card.children.length > 0 \n    ? card.children.map(childCard => cardToTreeItem(childCard))\n    : [];\n  \n  return {\n    id: card.id,\n    name: card.name,\n    type: card.is_folder ? 'folder' : 'card',\n    parent_id: card.parent_id,\n    is_folder: card.is_folder,\n    children: children,\n    isExpanded: false, // Start collapsed\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created,\n  };\n};\n\n// Build tree structure from hierarchical cards (from /cards/hierarchy endpoint)\nexport const buildTree = (cards: Card[], expandedIds?: Set<number>): TreeItem[] => {\n  // The /cards/hierarchy endpoint returns cards with children already populated\n  // So we just need to recursively convert them to TreeItems\n  const cardToTreeItemWithExpanded = (card: Card): TreeItem => {\n    const children = card.children && card.children.length > 0 \n      ? card.children.map(childCard => cardToTreeItemWithExpanded(childCard))\n      : [];\n    \n    return {\n      id: card.id,\n      name: card.name,\n      type: card.is_folder ? 'folder' : 'card',\n      parent_id: card.parent_id,\n      is_folder: card.is_folder,\n      children: children,\n      isExpanded: expandedIds ? expandedIds.has(card.id) : false, // Preserve expanded state\n      example_phrases: card.example_phrases,\n      meanings: card.meanings,\n      grammar_roles: card.grammar_roles,\n      collocations: card.collocations,\n      synonyms: card.synonyms,\n      antonyms: card.antonyms,\n      use_count: card.use_count,\n      notes: card.notes,\n      created_at: card.created_at,\n      user_created: card.user_created,\n    };\n  };\n\n  const treeItems = cards.map(card => cardToTreeItemWithExpanded(card));\n  \n  // Sort children by name\n  const sortChildren = (items: TreeItem[]) => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    \n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n\n  sortChildren(treeItems);\n  return treeItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree: TreeItem[], id: number): TreeItem | null => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree: TreeItem[], id: number, updates: Partial<TreeItem>): TreeItem[] => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return { ...item, ...updates };\n    }\n    if (item.children.length > 0) {\n      return { ...item, children: updateTreeItem(item.children, id, updates) };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree: TreeItem[], id: number): TreeItem[] => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (\n  tree: TreeItem[], \n  itemId: number, \n  newParentId: number | null\n): TreeItem[] => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n  \n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(findTreeItem(updatedTree, newParentId)?.children || []), itemToMove]\n    });\n  }\n\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree: TreeItem[], itemId: number): number[] => {\n  const findParentIds = (items: TreeItem[], targetId: number, currentPath: number[]): number[] | null => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      \n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      \n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = (tree: TreeItem[]): TreeItem[] => {\n  const result: TreeItem[] = [];\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return result;\n};\n\n// Get all expanded item IDs from a tree\nexport const getExpandedIds = (tree: TreeItem[]): Set<number> => {\n  const expandedIds = new Set<number>();\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      if (item.isExpanded) {\n        expandedIds.add(item.id);\n      }\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return expandedIds;\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}