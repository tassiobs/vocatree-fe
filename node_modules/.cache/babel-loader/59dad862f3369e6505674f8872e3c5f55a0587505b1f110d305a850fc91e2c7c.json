{"ast":null,"code":"// Convert API Card to TreeItem\nexport const cardToTreeItem = card => {\n  return {\n    id: card.id,\n    name: card.name,\n    type: 'card',\n    parent_id: card.parent_id,\n    children: [],\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created\n  };\n};\n\n// Build tree structure from flat array of cards\nexport const buildTree = cards => {\n  const cardMap = new Map();\n  const rootItems = [];\n\n  // First pass: create all items\n  cards.forEach(card => {\n    const treeItem = cardToTreeItem(card);\n    cardMap.set(card.id, treeItem);\n  });\n\n  // Second pass: build parent-child relationships\n  cards.forEach(card => {\n    const treeItem = cardMap.get(card.id);\n    if (card.parent_id === null) {\n      rootItems.push(treeItem);\n    } else {\n      const parent = cardMap.get(card.parent_id);\n      if (parent) {\n        parent.children.push(treeItem);\n      }\n    }\n  });\n\n  // Sort children by name\n  const sortChildren = items => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n  sortChildren(rootItems);\n  return rootItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree, id) => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree, id, updates) => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return {\n        ...item,\n        ...updates\n      };\n    }\n    if (item.children.length > 0) {\n      return {\n        ...item,\n        children: updateTreeItem(item.children, id, updates)\n      };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree, id) => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (tree, itemId, newParentId) => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n\n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    var _findTreeItem;\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(((_findTreeItem = findTreeItem(updatedTree, newParentId)) === null || _findTreeItem === void 0 ? void 0 : _findTreeItem.children) || []), itemToMove]\n    });\n  }\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree, itemId) => {\n  const findParentIds = (items, targetId, currentPath) => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = tree => {\n  const result = [];\n  const traverse = items => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  traverse(tree);\n  return result;\n};","map":{"version":3,"names":["cardToTreeItem","card","id","name","type","parent_id","children","example_phrases","meanings","grammar_roles","collocations","synonyms","antonyms","use_count","notes","created_at","user_created","buildTree","cards","cardMap","Map","rootItems","forEach","treeItem","set","get","push","parent","sortChildren","items","sort","a","b","localeCompare","item","length","findTreeItem","tree","found","updateTreeItem","updates","map","removeTreeItem","filter","moveTreeItem","itemId","newParentId","itemToMove","updatedTree","_findTreeItem","getParentIds","findParentIds","targetId","currentPath","newPath","result","flattenTree","traverse"],"sources":["/Users/tassiobs/Documents/vocatree-front/src/utils/treeUtils.ts"],"sourcesContent":["import { TreeItem } from '../types';\nimport { Card } from '../types/api';\n\n// Convert API Card to TreeItem\nexport const cardToTreeItem = (card: Card): TreeItem => {\n  return {\n    id: card.id,\n    name: card.name,\n    type: 'card',\n    parent_id: card.parent_id,\n    children: [],\n    example_phrases: card.example_phrases,\n    meanings: card.meanings,\n    grammar_roles: card.grammar_roles,\n    collocations: card.collocations,\n    synonyms: card.synonyms,\n    antonyms: card.antonyms,\n    use_count: card.use_count,\n    notes: card.notes,\n    created_at: card.created_at,\n    user_created: card.user_created,\n  };\n};\n\n// Build tree structure from flat array of cards\nexport const buildTree = (cards: Card[]): TreeItem[] => {\n  const cardMap = new Map<number, TreeItem>();\n  const rootItems: TreeItem[] = [];\n\n  // First pass: create all items\n  cards.forEach(card => {\n    const treeItem = cardToTreeItem(card);\n    cardMap.set(card.id, treeItem);\n  });\n\n  // Second pass: build parent-child relationships\n  cards.forEach(card => {\n    const treeItem = cardMap.get(card.id)!;\n    \n    if (card.parent_id === null) {\n      rootItems.push(treeItem);\n    } else {\n      const parent = cardMap.get(card.parent_id);\n      if (parent) {\n        parent.children.push(treeItem);\n      }\n    }\n  });\n\n  // Sort children by name\n  const sortChildren = (items: TreeItem[]) => {\n    items.sort((a, b) => {\n      // Folders first, then cards\n      if (a.type !== b.type) {\n        return a.type === 'folder' ? -1 : 1;\n      }\n      return a.name.localeCompare(b.name);\n    });\n    \n    items.forEach(item => {\n      if (item.children.length > 0) {\n        sortChildren(item.children);\n      }\n    });\n  };\n\n  sortChildren(rootItems);\n  return rootItems;\n};\n\n// Find item in tree by ID\nexport const findTreeItem = (tree: TreeItem[], id: number): TreeItem | null => {\n  for (const item of tree) {\n    if (item.id === id) {\n      return item;\n    }\n    const found = findTreeItem(item.children, id);\n    if (found) {\n      return found;\n    }\n  }\n  return null;\n};\n\n// Update item in tree\nexport const updateTreeItem = (tree: TreeItem[], id: number, updates: Partial<TreeItem>): TreeItem[] => {\n  return tree.map(item => {\n    if (item.id === id) {\n      return { ...item, ...updates };\n    }\n    if (item.children.length > 0) {\n      return { ...item, children: updateTreeItem(item.children, id, updates) };\n    }\n    return item;\n  });\n};\n\n// Remove item from tree\nexport const removeTreeItem = (tree: TreeItem[], id: number): TreeItem[] => {\n  return tree.filter(item => {\n    if (item.id === id) {\n      return false;\n    }\n    if (item.children.length > 0) {\n      item.children = removeTreeItem(item.children, id);\n    }\n    return true;\n  });\n};\n\n// Move item to new parent\nexport const moveTreeItem = (\n  tree: TreeItem[], \n  itemId: number, \n  newParentId: number | null\n): TreeItem[] => {\n  // Find the item to move\n  const itemToMove = findTreeItem(tree, itemId);\n  if (!itemToMove) {\n    return tree;\n  }\n\n  // Remove from current location\n  let updatedTree = removeTreeItem(tree, itemId);\n  \n  // Update item's parent_id\n  itemToMove.parent_id = newParentId;\n\n  // Add to new location\n  if (newParentId === null) {\n    // Moving to root\n    updatedTree.push(itemToMove);\n  } else {\n    // Moving to a parent\n    updatedTree = updateTreeItem(updatedTree, newParentId, {\n      children: [...(findTreeItem(updatedTree, newParentId)?.children || []), itemToMove]\n    });\n  }\n\n  return updatedTree;\n};\n\n// Get all parent IDs for a given item (for breadcrumb navigation)\nexport const getParentIds = (tree: TreeItem[], itemId: number): number[] => {\n  const findParentIds = (items: TreeItem[], targetId: number, currentPath: number[]): number[] | null => {\n    for (const item of items) {\n      const newPath = [...currentPath, item.id];\n      \n      if (item.id === targetId) {\n        return currentPath; // Return path without the target item itself\n      }\n      \n      if (item.children.length > 0) {\n        const result = findParentIds(item.children, targetId, newPath);\n        if (result) {\n          return result;\n        }\n      }\n    }\n    return null;\n  };\n\n  return findParentIds(tree, itemId, []) || [];\n};\n\n// Flatten tree to array (useful for drag and drop operations)\nexport const flattenTree = (tree: TreeItem[]): TreeItem[] => {\n  const result: TreeItem[] = [];\n  \n  const traverse = (items: TreeItem[]) => {\n    items.forEach(item => {\n      result.push(item);\n      if (item.children.length > 0) {\n        traverse(item.children);\n      }\n    });\n  };\n  \n  traverse(tree);\n  return result;\n};\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}